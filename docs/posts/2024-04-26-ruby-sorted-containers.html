<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title> Garrison Jensen - Sorted Containers in Ruby inspired by Python</title>
	<link rel="stylesheet" href="../css/tufte.css" />
	<link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">garrison</a>
            </div>
        </header>
	    <article>
		    <h1>Sorted Containers in Ruby inspired by Python</h1>
		    <p class="subtitle">
Posted on April 26, 2024

</p>
<section>
	<h2 id="quick-links">Quick Links</h2>
<ul>
<li>sorted_containers on <a href="https://github.com/GarrisonJ/sorted_containers">Github</a></li>
<li>sorted_containers on <a href="https://rubygems.org/gems/sorted_containers">RubyGems</a></li>
<li>sorted_containers <a href="https://www.rubydoc.info/gems/sorted_containers">Documentation</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>I converted Grant Jenks’s Python library <a href="http://www.grantjenks.com/docs/sortedcontainers/">Sorted Containers</a> to Ruby. If you are interested in the details of this data structure, I recommend reading his website. His documentation is much more detailed, and I used it as a reference for this implementation.</p>
<p>The library provides a fast sorted array, sorted set, and sorted hash implemented in pure Ruby with no dependencies.</p>
<p>SortedArray, SortedSet, and SortedHash are meant to be drop-in replacements for Array, Set, and Hash but with the extra property that the elements can be accessed in sorted order.</p>
<p>I compare the performance of SortedContainers to <a href="https://github.com/knu/sorted_set">SortedSet</a> a C extension red-black tree implementation. You can see the benchmarks below. The performance is comparable for add and delete, and much better for iteration, initialization, and lookup.</p>
<p>Some methods from Array, Set, and Hash have not been implemented in SortedContainers. I want to complete these before version 1.0.0. Feel free to open an issue if you would like a method added or add a pull request if you would like to contribute.</p>
<p>Feedback is welcome. I hope you find this library useful.</p>
<h2 id="how-it-works">How it works</h2>
<p>Modern computers are good at shifting arrays. For that reason, it’s often faster to keep an array sorted than to use the usual tree-based data structures.</p>
<p>For example, if you have the array <code>[1,2,4,5]</code> and want to insert the element <code>3</code>, you can shift <code>4, 5</code> to the right and insert <code>3</code> in the correct position. This is a <code>O(n)</code> operation, but in practice it’s fast.</p>
<p>You also save memory by not having to store pointers to children nodes, and you benifit from the cache locality of arrays. When you iterate over a sorted array, you are more likely to access elements that are close together in memory.</p>
<p>But we can do better if we have a lot of elements. We can break up the array so fewer elements have to be moved when a new element is inserted. For example, if you have the array <code>[[1,2,4],[5,6,7]]</code> and you want to insert the element <code>3</code>, you can insert <code>3</code> into the first array to get <code>[[1,2,3,4],[5,6,7]]</code> and only the element <code>4</code> has to be shifted.</p>
<p>This often outperforms the more common tree-based data structures like red-black trees with <code>O(log n)</code> insertions, deletions, and lookup. We sacrifice theoretical time complexity for practical performance.</p>
<p>The size of the subarrays is a trade-off. You can modify how big you want to subarrays by setting the <code>load_factor</code>. The default is set to <code>DEFAULT_LOAD_FACTOR = 1000</code>. The subarray is split when its size is <code>2*load_factor</code>. There is no perfect value. The ideal value will depend on your use case and may require some experimentation.</p>
<p>SortedSet and SortedHash are implemented using a SortedArray to keep track of the order, and then also use a standard Set and Hash for quick lookups.</p>
<h2 id="caveats">Caveats</h2>
<ul>
<li>Items must be comparable. If you try to insert an element that is not comparable, you will get an error.</li>
<li>The order of the items must not change after they are inserted, or the container will be corrupted.</li>
</ul>
<h2 id="benchmarks">Benchmarks</h2>
<p><a href="https://github.com/knu/sorted_set">SortedSet</a> is a C extension red-black tree implementation. I used it as a benchmark to compare the performance of SortedContainers.</p>
<p>Every test was run 5 times and the average was taken.</p>
<p>You can see that SortedContainers has compariable performance for add and delete, and much better performance for iteration, initialization, and include.</p>
<p>I did my best to make the tests as fair as possible, but it’s possible that I made a mistake. It’s also difficult to predict real-world performance from these tests. If you have any suggestions for improvement, please let me know by opening an issue. The code for the benchmarks can be found in the github repository.</p>
<ul>
<li>MacBook Pro (16-inch, 2019)</li>
<li>2.6 GHz 6-Core Intel Core i7, 16 GB 2667 MHz DDR4</li>
<li>Ruby 3.2.2</li>
<li>SortedContainers 0.1.0</li>
<li>SortedSet 1.0.3</li>
</ul>
<h3 id="results-lower-is-better">Results (Lower is better)</h3>
<figure>
<label for="initalize-performance" class="margin-toggle">⊕</label><input type="checkbox" id="initalize-performance" class="margin-toggle"><span class="marginnote">Initialize a Sorted Set with <em>N</em> elements</span>
<img src="https://github.com/GarrisonJ/sorted_containers/blob/main/benchmark/initialize_performance_comparison.png?raw=true" alt="Graph showing Initialization performance comparison">
</figure>
<figure>
<label for="add-performance" class="margin-toggle">⊕</label><input type="checkbox" id="add-performance" class="margin-toggle"><span class="marginnote">Add <em>N</em> elements to a Sorted Set</span>
<img src="https://github.com/GarrisonJ/sorted_containers/blob/main/benchmark/add_performance_comparison.png?raw=true" alt="Graph showing Add performance comparison">
</figure>
<figure>
<label for="delete-performance" class="margin-toggle">⊕</label><input type="checkbox" id="delete-performance" class="margin-toggle"><span class="marginnote">Delete <em>N</em> elements from a Sorted Set</span>
<img src="https://github.com/GarrisonJ/sorted_containers/blob/main/benchmark/delete_performance_comparison.png?raw=true" alt="Graph showing Delete performance comparison">
</figure>
<figure>
<label for="iteration-performance" class="margin-toggle">⊕</label><input type="checkbox" id="iteration-performance" class="margin-toggle"><span class="marginnote">Iterate over a Sorted Set with <em>N</em> elements</span>
<img src="https://github.com/GarrisonJ/sorted_containers/blob/main/benchmark/iteration_performance_comparison.png?raw=true" alt="Graph showing Iteration performance comparison">
</figure>
<figure>
<label for="include-performance" class="margin-toggle">⊕</label><input type="checkbox" id="include-performance" class="margin-toggle"><span class="marginnote">Check if <em>N</em> elements are included in a Sorted Set</span>
<img src="https://github.com/GarrisonJ/sorted_containers/blob/main/benchmark/include_performance_comparison.png?raw=true" alt="Graph showing Include performance comparison">
</figure>
<h2 id="conclusion">Conclusion</h2>
<p>Feedback is welcome. Please open an issue on <a href="https://github.com/GarrisonJ/sorted_containers">Github</a> if you have any suggestions or find any bugs.</p>
<p>If you like Python libraries converted to Ruby, you might also like my conversion of <code>heapq</code> to Ruby called <a href="https://github.com/GarrisonJ/heapify">heapify</a></p>
</section>

	    </article>
        <footer>
        </footer>
    </body>
</html>
