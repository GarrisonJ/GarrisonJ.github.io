<p>On the front page of <a href="https://www.haskell.org/">Haskell.org</a>, you will see this implementation of the sieve of Eratosthenes:</p>

<div style="text-align:center;">
<img style="width: 100%;" src="/images/Screen.png" /> 
</div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">primes</span> <span class="o">=</span> <span class="n">sieve</span> <span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="p">]</span> 
  <span class="kr">where</span> <span class="n">sieve</span> <span class="p">(</span><span class="n">p</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> 
          <span class="n">p</span> <span class="o">:</span> <span class="n">sieve</span> <span class="p">[</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="n">p</span> <span class="o">/=</span> <span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>

<p>When you see this for the first time it’s amazing. But it’s <a href="http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf">not the sieve of Eratosthenes</a>.</p>

<p>The problem with the algorithm is the way it crosses-off numbers. In the true sieve of Eratosthenes when we find a prime number, \(p\), we start at \(p^2\) and from there we cross-off multiples of \(p\). For example, when calculating prime numbers less then 100, when we find 7 we start at 49 and cross-off 56, 63, 70, 77, 84, 91, and 98. That’s 8 operations. When the false algorithm finds 7, it checks every number from 8 to 100, that’s 92 operations!</p>

<div style="text-align:center">
<img src="/images/Sieve_of_Eratosthenes_animation.gif" alt="real seive animation, courtesy of Wikipedia" />
</div>

<p><a href="http://www.cs.hmc.edu/~oneill/">Melissa E. O’Neill</a> gives us a real functional, <a href="https://wiki.haskell.org/Lazy_evaluation">lazy</a>, implementation of the algorithm in her paper, <a href="http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf"><strong><em>The Genuine Sieve of Eratosthenes</em></strong></a>.</p>

<p>For every number, we check if it’s a multiple of a prime seen so far. We don’t have to check all the primes. We store the primes in a priority queue, indexed on the smallest multiple of it we have seen. We only compare the current number to the smallest index of the queue. If it equals our current number, we know our number must be a composite. We then increment the prime multiple to the next multiple of the prime, and insert it back into the queue. (We also have to adjust the queue because some numbers are inserted more than once. 12 will be in the queue twice because \(2^2+2+2+2+2=12\) and \(3^2+3=12\). Notice 12 is also crossed-off twice in the animation.)</p>

<p>We store multiples of primes as infinite lists. Laziness is key.</p>

<p>My interpretation of the algorithm uses <a href="https://downloads.haskell.org/~ghc/7.8.2/docs/html/libraries/containers-0.5.5.1/Data-Set.html">Data.Set</a> as a priority queue, because the functions <code class="language-plaintext highlighter-rouge">insert</code> and <code class="language-plaintext highlighter-rouge">findMin</code> are \(O(log(n))\).</p>

<hr />

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Set</span> <span class="k">as</span> <span class="n">PQ</span>

<span class="n">primes</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Integer</span><span class="p">]</span>
<span class="n">primes</span> <span class="o">=</span> <span class="mi">2</span><span class="o">:</span><span class="n">sieve</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="o">..</span><span class="p">]</span>
  <span class="kr">where</span>
    <span class="n">sieve</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">:</span> <span class="n">sieve'</span> <span class="n">xs</span> <span class="p">(</span><span class="n">insertprime</span> <span class="n">x</span> <span class="n">xs</span> <span class="kt">PQ</span><span class="o">.</span><span class="n">empty</span><span class="p">)</span>

    <span class="n">sieve'</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="n">table</span>
        <span class="o">|</span> <span class="n">nextComposite</span> <span class="o">==</span> <span class="n">x</span> <span class="o">=</span> <span class="n">sieve'</span> <span class="n">xs</span> <span class="p">(</span><span class="n">adjust</span> <span class="n">x</span> <span class="n">table</span><span class="p">)</span>
        <span class="o">|</span> <span class="n">otherwise</span>          <span class="o">=</span> <span class="n">x</span> <span class="o">:</span> <span class="n">sieve'</span> <span class="n">xs</span> <span class="p">(</span><span class="n">insertprime</span> <span class="n">x</span> <span class="n">xs</span> <span class="n">table</span><span class="p">)</span>
      <span class="kr">where</span> 
        <span class="p">(</span><span class="n">nextComposite</span><span class="p">,</span><span class="kr">_</span><span class="p">)</span> <span class="o">=</span> <span class="kt">PQ</span><span class="o">.</span><span class="n">findMin</span> <span class="n">table</span>

    <span class="n">adjust</span> <span class="n">x</span> <span class="n">table</span>
        <span class="o">|</span> <span class="n">n</span> <span class="o">==</span> <span class="n">x</span>    <span class="o">=</span> <span class="n">adjust</span> <span class="n">x</span> <span class="p">(</span><span class="kt">PQ</span><span class="o">.</span><span class="n">insert</span> <span class="p">(</span><span class="n">n'</span><span class="p">,</span> <span class="n">ns</span><span class="p">)</span> <span class="n">newPQ</span><span class="p">)</span>
        <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">table</span>
      <span class="kr">where</span>
        <span class="kt">Just</span> <span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n'</span><span class="o">:</span><span class="n">ns</span><span class="p">),</span> <span class="n">newPQ</span><span class="p">)</span> <span class="o">=</span> <span class="kt">PQ</span><span class="o">.</span><span class="n">minView</span> <span class="n">table</span>

    <span class="n">insertprime</span> <span class="n">p</span> <span class="n">xs</span> <span class="o">=</span> <span class="kt">PQ</span><span class="o">.</span><span class="n">insert</span> <span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">map</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="n">xs</span><span class="p">)</span>
</code></pre></div></div>
<hr />

<p>The difference in time it takes each algorithm to calculate the 10,000th prime number on my machine is huge:</p>

<p><strong>False sieve:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    real  0m7.913s
    user  0m7.886s
    sys   0m0.016s
</code></pre></div></div>

<p><strong>O’Neill’s algorithm:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    real  0m0.248s
    user  0m0.241s
    sys   0m0.004s
</code></pre></div></div>

<p>The false sieve takes almost <strong>8 seconds</strong>! Compare this to the real sieve which takes about <strong>0.24 seconds</strong>.</p>

<hr />

<p><a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Sieve gif courtesy of  Wikipedia.</a></p>

